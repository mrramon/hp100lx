# 8\. LHAPI

The System Manager's Lotus Handheld Application Programming Interface (LHAPI) services provide a set of function calls to simplify building an application's user interface and to handle keyboard input. These services provide menu-building functions, editing and display functions, window handling functions, as well as graphic display functions.

Each of the LHAPI services is prefaced with a Distance constant in order to allow for mixed-memory model applications. A developer can selectively set this constant to either "_near" or "_far", or leave it NULL in order to have all calls to LHAPI use the same model as that specified to the compiler.

As defined in Microsoft C Version 6.0, NULL is only used with pointers. Set any other variable to 0 (zero) in order to clear it.

Note that the system assumes it is in the following state:

* Mode = REP_RULE (Replace screen pixels)
* Color = 1 (Black)
* Pattern = Checkerboard (055h, 0AAh, 055h, 0AAh, ...)

All LHAPI-provided functions return with the graphics parameters set this way, and any functions that change these parameters should restore them.

## LHAPI Overview

LHAPI is like other Graphical User Interfaces (GUI's) in that it provides functions for directly manipulating the display, and windows (a.k.a. "objects") that are used to interact with the user. A typical LHAPI program will create a main window, and then based on interaction from the user, create dialogs. These dialogs will consist of controls that the user will manipulate; the program will then use that input accordingly. LHAPI is designed to operate on a limited-space machine, so unlike other GUI's, the application is held responsible for more of the work in getting a window up and running.

Although not strictly object-oriented, does LHAPI does communicate between windows with messages. These messages are used to tell, for example, an edit window to accept a keystroke, or for a list box to redraw itself, etc. Like OOP, LHAPI objects can be "reused" by subclassing the object and adding/removing functionality. An example of this might be creating a date-only edit field by subclassing the edit field, and adding the ability to parse dates.

An application under LHAPI is event driven--it operates on messages generated by the user. These messages from the most part come from the user (which come in turn from the System Manager). Thus, a LHAPI application consists of three primary parts:

* The Event Loop. The application needs to get messages from the System Manager, and feed them to LHAPI. This portion of an application is relatively standard; E_KEY events from the System Manager are translated into KEYSTROKE messages sent to the focus window, etc.
* The Window Handlers. The application itself consists mostly of a Main Window. The handler for that Window (i.e., the code associated with maintaining that window) is the thing that distinguishes that application from all others. Windows handlers are needed for processing input from dialogs, or for creating specialized classes of control windows that LHAPI does not directly support.
* The Window Data. Every window created by LHAPI requires a window structure. This window structure is allocated by the application; a pointer to a window structure is the way that LHAPI typically refers to a window (analogous to a "handle" under other systems). Many times, other associated structures are needed to maintain a window. These include information directly related to the window such as edit buffers, places to store radio button/checkbox selections, but also include menu and function key structures. Much of the "flow of control" of LHAPI applications is embedded in menu and function key structures, since these allow different sets of user actions associated with windows coming in and out of creation. For example, a main application may have ten specialized functions on the function keys, but when a dialog comes up, only OK and Cancel are available. This is automatically handled by LHAPI by setting up different function key structures for each window.

### LHAPI Initialization

A LHAPI application is also a System Manager application. First, a LHAPI app must register itself as a System Manager application, then register itself as a LHAPI application. The two are very distinct, and although you can have a System Manager application without LHAPI, you cannot have a LHAPI application without the System Manager. Here is a typical initialization:

```c
// Register ourself with the System Manager:
m_init_app(SYSTEM_MANAGER_VERSION);

// Register our application's name (the user will see this):
m_reg_app_name("My Test App");

// Register our far pointer table (in case we need to make dynamic memory allocations:
#define countof(x) (sizeof(x) / sizeof(x[0]))

char far *SysMgrFarPtrs[10];

m_reg_far(&SysMgrFarPtrs, countof(SysMgrFarPtrs), 0);
```

Next, any initialization required for LHAPI should be done.

```c
// Register our application with LHAPI.
LHAPIBLOCK LHAPIData;

InitializeLHAPI(&LHAPIData);

// Set the default font and the menu font to 64x18
SetMenuFont(FONT_NORMAL);

SetFont(FONT_NORMAL);
```

### The LHAPI Event Loop

After a LHAPI application is done initializing itself, it usually falls into the event loop. The event loop just gets events, and doles them out. The entire life of an application is normally spent inside an event loop. One single event loop (as opposed to multiple event loops or nested event loops) is preferred; the System Manager can lose track of the thread of execution in deeply nested LHAPI calls with multiple event loops. A somewhat standard event loop might look like this:

```c
int EventLoop(void)
{
    int Done = 0;                   /* Application termination flag */

    EVENT app_event;

    while (!Done) {                 /* While app not terminated */
        app_event.do_event = DO_EVENT;  /* Grab event from system manager */

        m_action(&app_event);

        switch (app_event.kind) {       /* Branch on SysMgr event */
        case E_REFRESH:                 /* SysMgr wants to redisplay our screen*/
        case E_ACTIV:                   /* Swapping back to our app */
            FixupFarPtrs();                 /* If app needs to fix pointers, do it here */
            ReactivateLHAPI(&LHAPIData);
            break;

        case E_DEACT:                   /* User swapping to another app */
            DeactivateLHAPI();
            break;

        case E_TERM:                    /* User wants to kill our app */
            FixupFarPtrs();                 /* Fix up any far pointers */
            Done = TRUE;                    /* Set application terminate flag */
            break;

        case E_NONE:                    /* Nothing has happened for 1/2 second */
            SendFocusMsg(NULLEVENT, app_event.shifts, app_event.scan);
            break;

        case E_KEY:                     /* User has pressed a key */
            SendFocusMsg(KEYSTROKE, app_event.data, app_event.scan);
            break;
        }
    }
}
```

Obviously, application may need to modify this basic event loop. For example, an application that supports the database engine needs to take other precautions. This event loop can serve a starting place, however.

### Quitting a LHAPI Application

When the user signifies that they want to terminate the application, the application falls out of the event loop, and quits. This quitting usually involves nothing more than:

```c
    app_event.do_event = DO_FINI;

    m_action(&app_event);
```

### LHAPI Window Handlers

Every window in LHAPI has a window handler, and every window handler has the same prototype. The window handler responds to messages sent to windows of that class, and deals with them accordingly. For many of the windows in a LHAPI application, you will be able to use a window handler supplied by LHAPI. These are the LHAPI Base Classes, and include Edit fields, Radio Buttons, Check Boxes, Dialog Boxes, and other specialized controls.

To create your own window handler, you need to decide what class it is a desendant of. The class you create will be a subclass\x110011of that class. If the class of window you create does not have an already existing equivalent, it would be derived from the Object class, which is the basis for all LHAPI window handlers. As an example, you decide you need a class that only accepts uppercase input--all lowercase letters should be converted to uppercase. This would be a subclass of an Edit control, and would look something like this:

```c
int far UpperOnlyEditHandler(PWINDOW Wnd, WORD Message, WORD Data, WORD Extra)
{
    switch (Message) {
    case KEYSTROKE:
    if (Data >= 'a' && Data <= 'z') Data -= 'a' + 'A';

    /* !!!  FALL THROUGH TO DEFAULT CASE */
    default:
        return SubclassMsg(Edit, Wnd, Message, Data, Extra);
    }
}
```

This example is pretty simple, but illustrates the basic mechanism of subclassing. You create a window handler prototype, case out the messages that you are interested in, respond to them if needed, and possibly pass them on to the "parent" class via SubclassMsg. Depending on the circumstances, you may want to intercept messages before or after the subclass operates on them, or not pass the messages on through at all. Usually, you want to pass any messages that you don't handle on to the subclass; even simple classes such as the Object class handles keystrokes to bring up the menu, or null events to update the clock on the title bar. For a more complex example on how to subvert LHAPI classes by subclassing them, see the example PASSWORD.C on the ISV disk.

An application's main window will probably be a subclass of Object, and will need to handle DRAW and KEYSTROKE messages at a minimum.

The other type of handler is the function key or menu event handler. These handlers are very simple--they take no parameters, and return none. Their sole purpose is to act on an event selected by the user. For example, there might be a function key and a menu item in a window that should bring up help. You will have one help handler that is just a function dedicated to bringing up help. In both the function key structure and the menu structure associated with that window, entries will refer to that function, so that LHAPI will call it on selecting the menu item or pressing the function key.

### LHAPI Window Data

Each window in an application requires a window structure: even control windows. A window structure for an application's main window might look like this.

```c
LHWINDOW MyTopWindow = {
    MyTopHandler,
    0, 0, 640, 190,
    &msgAppTopLine, 0,
    0, 0,
    NULL, MyFKeys, TopMenu, NO_HELP
};
```

This sets up a window called MyTopWindow that uses MyTopHandler to process the window's messages. The size of the window is full screen except the function key area, has a title pointed to by msgAppTopLine, and function keys and menu called MyFKeys and TopMenu.

A dialog window, its controls, and associated data might look something like this:

```c
/* Prototype for function key handlers */
void far CompleteMyDialog(void);

/* Actual data buffers that are filled in by the user */
char NameBuffer[50];
int IsEccentric;
int Gender;

/* Titles of the dialog, controls, and function keys */
char far *msgMyDialogTitle      = "A Silly Dialog Example";
char far *msgNameTitle          = "Name";
char far *msgEccentricTitle     = "Eccentric?";
char far *msgSex                = "Gender";
char far *msgFemale             = "Female";
char far *msgMale               = "Male";
char far *fkeyOK                = "OK";
char far *fkeyCancel            = "Cancel";

/* Function keys used by the dialog */
LHFKEY MyFKeys[] = {
    { &fkeyCancel, (PFUNC)CMD_ESC, 9, FKEY_SENDMSG },
    { &fkeyOK, CompleteMyDialog, 10 + LAST_FKEY, 0 }
};

/* Array of dialog controls for MyDialogBox */
LHWINDOW MyDialogArray[] = {
    {
        Edit, 10, 15, 24, 1,                         /* 0 = Name */
        &msgNameTitle, NameBuffer,
        sizeof(NameBuffer),
        EDIT_INSERT | STYLE_WHCHAR, NULL, PARENT_FKEYS, NO_MENU, NO_HELP
    },
    {
        CheckBox, 496, 39, 1, 1,                     /* 1 = Eccentric */
        &msgEccentricTitle, (PLHDATA)IsEccentric,
        1, STYLE_WHCHAR, NULL, PARENT_FKEYS, NO_MENU, NO_HELP
    },
    {
        GroupBox, 306, 61, 329, 37,                   /* 2 = Sex */
        &msgSex, NULL,
        0, 0, NULL, PARENT_FKEYS, NO_MENU, NO_HELP
    },
    {
        RadioButton, 426, 76, 1, 1,                   /* 3 = Female */
        &msgFemale, (PLHDATA)Gender,
        'F', 0, MyDialogArray + 2, PARENT_FKEYS, NO_MENU, NO_HELP
    },
    {
        RadioButton, 514, 76, 1, 1,                   /* 4 = Male */
        &msgMale, (PLHDATA)Gender,
        'M', 0, MyDialogArray + 2, PARENT_FKEYS, NO_MENU, NO_HELP
    },
};

LHWINDOW MyDialogBox = {
    DialogBox,
    5, 8, 480, 160,
    &msgMyDialogTitle, (PLHDATA)MyDialogArray,
    countof(MyDialogArray), 0,
    NULL, MyFKeys, NO_MENU, NO_HELP
};
```

A couple of things to note about this example.

* The Radio Buttons are children of the Group Box. The parent field is set to "MyDialogArray+2", which is the address of the Group Box control in MyDialogArray.
* The function "CompleteMyDialog" will get called if the user presses F10. This function should save or process the information that will be stored in the NameBuffer, Iscentric, and Gender fields, and destroy the dialog by sending it a DESTROY message.
* The titles in the controls are actually near pointers to far pointers to strings. Since your DS can move, you need to be able to "fix" these far pointers. That is, the DOS loader will set the segment values of those far pointers to the initial Data Segment that the program is loaded at, but the System Manager can move the Data Segment. This will cause the far pointers to be pointing into space, since there isn't any automatic support for fixing this. The standard way of handling this is to keep all far pointers in a table, and fix the entries in that table when your application is reactivated.

### LHAPI Messaging

The application communicates to its windows by sending them messages. Messages cover all aspects of window management: creation, destruction, changing the focus (the window the user is currently interacting with), keyboard input, and display. Usually, a message chain is initiated by the System Manager sending the application an event. This may be an activation event, or the user typing a key. This message is in turn passed to one or some windows. Those windows may in turn call other windows, or may subclass the message to allow other handlers to function on that same window.

For the most part, you don't need to worry about this messaging while writing LHAPI window handlers; just handle the messages you need to. You cannot do this, however, in a vacuum. When writing a window handler (especially one that subclasses an existing class' behavior), keep these things in mind:

* How does the class interact with its subclass? Are there certain messages that are necessary to prevent sending to the subclass? Depending on what you are trying to accomplish, you may need to parcel the message off to the subclass, and then handle it, rather than trying to make it work the other way around. Are there cases that you might not be handling? A common one is subclassing KEYSTROKE, but forgetting that the user can paste into the field. Some of the LHAPI classes do not always send themselves messages when DRAWing--you may need to trap messages (e.g. KEYSTROKE) in addition to the obvious ones in order to make the control behave properly.
* How does the class interact with its parents or children? A dialog box CREATEs itself, then all its children; it DESTROYs all its children before it destroys itself. Does this make a difference for your control that is subclassing CREATE or DESTROY? RadioButtons require their parent be a Group Box to properly handle messages. Similarly, most other controls require their parent directly be the dialog box, even if they are inside a group box. Since Object sends many unhandled messages to the window's parent window, these relationships can become important.
* Does the class interact with other windows on the screen? A combo box communicates with a listbox that is "attached" by pointing the Menu field at the list. These two windows send each other messages to keep the other up to date. In a FileOpenDialogBox, the dialog is communicating with the edit, directory and file lists, which are communicating with each other. In situations like these, subclassing needs to be thought out carefully. Try to make the least amount of impact on the messages flying through the class as you can.
* Is the inter-window messaging very deep (i.e. could you possibly run out of stack)? In deeply nested complex dialog boxes, you may be using up much more stack space than you are aware of, with all the messages being sent from window to window. LHAPI messages must be handled before they return to the caller: they are not queued. This means that if five windows send cascaded messages to each other, there will be at least five message stack frames on the stack at the deepest window. It doesn't pay to be stingy with stack space in a LHAPI application. You may wish to check validity of variables high up in your data space during operation of complex dialogs before you're done testing your application.

### Using the FileOpenDialogBox class

The FileOpen dialog box is one of the more difficult LHAPI classes to use, since it involves a window that has a complex interation with other windows. This section will try to explain how to use a FileOpenDialogBox. For a concrete example, see the file FILEDLGS.C provided with the ISV disk.

FileOpenDialogBox requires that the control windows in its window array start with these six windows: Edit, PathText, FileListBox,DirListBox,Ok PushButton, Cancel PushButton. There may be more than these windows, but there must be at least these six. The FileOpenDialogBox coordinates with the Edit, PathText, FileListBox and the DirListBox via NOTIFY messages. The children have the STYLE_NOTIFY bit set so that they will send NOTIFY_CHILDCHANGED messages to the F.O.D.B. The DialogBox will then change directories in the FileListBox and the DirListBox by sending them NOTIFY, NOTIFY_UPDATE messages with the Extra field set to the new directory path.

Various information about the status of the file operation is scattered throughout the controls in the file dialog array. In some cases, the Menu field of a control is usurped to function specially for FileOpenDialog.

* The buffer that is pointed to by the first Edit control is the buffer where the resulting filename will reside. If the buffer contains a non-null string when the dialog is created, that will be used as the wildcard specification. In the FILEDLGS example, this buffer is called FileSpec.
* The Menu field of the Edit control points to a default wildcard, e.g. "*.PDB"
* The buffer that is pointed to by the Directory static text (the PathText control) is the directory where files will initially be displayed. The directory should not end in a backslash unless the directory is the root. In the FILEDLGS example, this buffer is called Directory.
* The FileListBox points to an array of pointers--these pointers must point to buffers that are used to fill in the filenames read from disk. While the window is active, the LogicalSize field will be the current number of files in the list (i.e., the total number of pointers currently being used); the Menu field contains the total size of the list (i.e., the total number of pointers allocated). In the FILEDLGS example, the pointer array is called FileList; the buffer space allocated to fill the names is called FileSpace. During InitializeFileDialogs(), the pointers in FileList are pointed into FileSpace.
* The DirListBox points to an array of pointers--these pointers must point to buffers that are used to fill in the directories read from disk. While the window is active, the LogicalSize field will be the current number of directories in the list (i.e., the total number of pointers currently being used); the Menu field contains the total size of the list (i.e., the total number of pointers allocated). In the FILEDLGS example, the pointer array is called DirList; the buffer space allocated to fill the names is called DirSpace. During InitializeFileDialogs(), the pointers in DirList are pointed into DirSpace.

The example in FILEDLGS has subclassed the FileOpenDialogBox handler. This is to make sure that the two ways to acknowledge the dialog, either by pressing F10 or by pressing Enter, both perform some post-processing on the filename to add a default extension if necessary.

### Other LHAPI Details

Other miscellaneous topics on how to make LHAPI work for you.

**Global and Local Clipping.**

When a window is destroyed, how does the underneath screen get restored? If the window was created with the style STYLE_SAVEUNDER, the screen underneath the window was (probably) saved in a buffer, which will just be restored to the screen. If that style is not used (and its use is only encouraged sparingly), then LHAPI needs to send the windows underneath DRAW messages to repair that portion of the screen. To prevent distracting flashing of the screen, LHAPI, in cooperation with the 100LX/200LX graphics subsystem, sets clipping regions. When a window is destroyed, a Global clipping region is set to encompass that window's screen extent. All graphics output through the ROM graphics routines will be clipped to the rectangle that formerly displayed that window's output. All active windows are then sent a DRAW message. They will all draw themselves, but only if their window surface intersects the destroyed window will it actually show up.

In addition to a GlobalClipping region, a LocalClipping region can be set by an application to prevent it from drawing outside a certain area. The Edit and ListBox classes do this to keep long words from overflowing the bounds of the box on screen. The 100LX/200LX graphics only directly supports one level of clipping--LHAPI internally manages intersecting the two and passing the results on to the graphics subsystem.

LHAPI provides calls for managing clipping regions. If an application window needs to clip, it should use SetLocalClipping(). LHAPI should be the only one calling SetGlobalClipping, and it should be the only one calling the clipping services in the ROM graphics directly.

**Invisible Windows, or How do I prevent flashing?**

If you read the previous topic about clipping, you might wonder "With all that redrawing going on, how come the built-in applications don't flash as much as mine does?" This might involves a little optimization of your application. In the 100LX/200LX software, where there are full screen dialogs or card views, the underlying index view is still a window, but we mark it invisible. This prevents a useless redraw of the underlying index view if you task switch to the application, or if another window comes up and is destroyed. If you have a dialog that is full screen, or another window that completely overlays another, you may want to put code in its CREATE case that makes the underlying window invisible and code in its DESTROY case to make it visible again. Another way to use invisible/visible windows is in a dialog that has options that are dependent on other selections. Checking a check box might make more options on that page accessible, which could be done by hiding the windows initially, and tying the check box checking to make those extra windows visible.

Invisible windows are automatically handled in all the LHAPI supplied classes, but LHAPI doesn't do anything for your own window classes. For windows that you want to respond to STYLE_INVISIBLE, you will need to put a test in your window's draw handler to break, like this:

```c
int far MyHandler(PLHWINDOW Wnd, WORD Message, WORD Data, WORD Extra)
{
    switch (Message) {
    case DRAW:
        /* Make this window ignore all drawing if it is marked as Invisible */
        if (Wnd->Style&STYLE_INVISIBLE) break;

        /* Do the rest of the window's drawing...  */
        .
        .
        .
    }
}
```

If you set windows to be visible or invisible, you need to not only set the STYLE_INVISIBLE bit, but also the STATUS_VISIBLE bit. Keeping these two bits in sync is important when LHAPI trys to redraw all your windows on a ReactivateLHAPI; some of the windows might be ignored if they don't have the STATUS_VISIBLE bit set accordingly. So to set a window Wnd Invisible, use:

```c
    Wnd->Style |= STYLE_INVISIBLE;

    Wnd->Status &= ~STATUS_VISIBLE;
```

and to set it visible again use:

```c
    Wnd->Style &= ~STYLE_INVISIBLE;

    Wnd->Status |= STATUS_VISIBLE;
```

Obviously, when making the window visible again, you will need to send the window a draw message at some point to cause the window to be redrawn!

**Dynamic Function Keys.**

In another attempt to minimize screen flash, LHAPI will not redraw the function keys if it can help it. If many windows are being created and destroyed with the same set of function keys, LHAPI does a good job of not wasting CPU cycles redrawing the function keys that are already there. If you are trying to manage a set of dynamic function keys, i.e. a LHFKEY array that you are setting up at run time, you might have problems. LHAPI will only display the function keys the first time they are displayed, since it "knows" whether the set is new or not by comparing pointers. Setting the FkeyPtr field in your LHAPI block to 0 after you make changes to you function keys will ensure they will be displayed the next time around.

If you want to prevent function keys from being displayed, you can set the focus window's Fkey field to NO_FKEYS (the static approach). Another way to do the same thing that is a little bit more dynamic is by clearing the DRAW_FKEYS bit from the Data word in that windowhandler before passing it on to Object. The Object handler is the one that updates the function keys (if the DRAW message's Data field has the DRAW_FKEYS bit set).

**Title Windows and Maintaining Far Pointers.**

Since Titles of windows need to be near pointers to far pointers to strings, this means that if the data segment of the application moves, those far title pointers need to be fixed with the new DS. These are called "resourced" strings, since the double indirection is there to allow the messages to be read in from resource files. Resource files are very convienent when localizing your product for foreign environments, since the resource file contains the strings, and that is the only piece of your product that needs to change. See the System Manager chapters for more information on resourcing strings.

There are two common ways to fix up your pointers. The first and safest method is to let the System Manager automatically manager these pointers. In your far pointer table, allocate enough extra entries for all of your resourced strings. When you register the table with the System Manager, set the number of user entries (the 3rd parameter) to the number of these far title pointers. In initialization, fill the user entries with your far pointers to the strings. Make sure you use entries starting from the back of the table, not the front. For example:

You need to allocate 10 memory blocks, and you have 125 messages that are resourced. Your m_reg_far statement would look like this:

```c
    char far *MyFarPointerTable[135];

    m_reg_far(&MyFarPointerTable,135,125);
```

Now when filling the table with your far pointers to your resourced strings, start at the end of the table; the 125 user entries that you reserved are the last 125 entries. The first 10 entries are reserved for the System Manager to manage any far memory blocks you allocate within your application. Your windows will have near pointers that will point into the far pointer table, and the far pointer entries will point to the strings. The simplest possible scenario for this would be:

```c
char MyMessage[] = "Hello World!";

char far *MyFarPointerTable[1];

LHWINDOW MyDialogBox = { DialogBox, 0, 0, 640, 180, &MyFarPointerTable[0] };

void Initialize(void)
{
    m_reg_far(&MyFarPointerTable, 1, 1);
    MyFarPointerTable[0] = MyMessage;
    .
    .
    .
}
```

The benefit of this method is that the System Manager will automatically take care of fixing the far pointers any time your application's DS moves. Once it is set up, you never have to worry about it again. Herein lies the biggest problem with this method; setting it up is not trivial because your windows have to give a far pointer table entry. This isn't very descriptive in the Window Title since it is just a table index, and also makes managing lots of messages difficult.

Another approach that requires more dilligence on the application writer's part, but that preserves an easy naming scheme, is to manually fix the pointers. This approach requires that you put all the far pointers into a table that you fix up during Initialization, Reactivates, and Memory allocation calls. This might look a lil' sumthin' like this: char far *MyMessage="Hello World!";

```c
char far **StringTable[] = {
    &MyMessage,
};

LHWINDOW MyDialogBox = { DialogBox, 0, 0, 640, 180, &MyMessage };

void FixupFarPtrs(void)
{
    int i;
    int dataseg;

    _asm {
        mov ax, ds
        mov dataseg, ax
    }

    for (i = 0; i < countof(StringTable); i++)
        *(((int *)(StringTable[i])) + 1) = dataseg;
}

void Initialize(void)
{
    FixupFarPtrs();
    .
    .
    .
}
```

With this approach, you will need to be very careful to make sure you call FixupFarPtrs() whenever you get an E_ACTIV event, or whenever you allocate memory.

### What is CAP?

Examining some of the programs on the distribution disk will give you a good idea of how to use LHAPI applications to your advantage. Unfortunately, some of those example applications may have been developed under "CAP", which was a predecessor to LHAPI. Therefore, you might see references like **#include "cap2.h"**, or **CAPBLOCK CapData** or **InitializeCAP();** These elements are vestiges of a former time--the best thing to do is use the examples as a stylistic guide, and don't get too worried if you see structure or function names that you don't recognize. Almost all of the names have a direct equivalence--the file "cap2.h" contains the many #defines that map CAP names to LHAPI names.

## Service Overview

There are many function calls associated with LHAPI Services, including:

Global LHAPI Control Functions include

* InitializeLHAPI First time initialization by applications to point to a LHAPIBLOCK structure allocated by the application.
* DeactivateLHAPI Application tells LHAPI that it is switching out.
* ReactivateLHAPI Reestablishes the LHAPIBLOCK data structure after being switched back in.
* UninitializeLHAPI Application tells LHAPI it is terminating.
* GetLHAPIBlockPtr Returns the offset address of the currently defined LHAPIBLOCK structure.

Messaging functions include

* SendAllMsg Sends the specified message to all windows in the active application.
* SendFocusMsg Sends the specified message to the focus window.
* SendMsg Sends the specified message to the specified window.
* SubclassMsg Sends the specified message to the specified window using a different class handler than the one specified in the LHWINDOW structure.

Menu functions include

* ResetAlt Resets an internal flag so that the Object class will not generate a \<Menu\> KEYSTROKE message if it sees an \<Alt\> release keystroke. Normally only called internally by LHAPI.

Focus functions include

* GetFocus Returns a pointer to the current window with focus.

Error Handling functions include

* SetError Saves the specifed value in ErrorNum in the LHAPIBLOCK structure.
* GetError Returns ErrorNum.
* ClearError Clears both the ErrorNum and the Handler field in the LHAPIBLOCK structure.
* SetErrorHandler Sets the Handler for Error.
* GetErrorHandler Gets current error handler.

LHAPI specialized text display routines include

* DrawText Draws text on the screen.
* DrawNChars Similar to DrawText, but specifies the maximum characters to display.
* DrawChar Displays a single character in the specified Draw style and font.
* DrawFKeys Displays the function-key labels for a window.

LHAPI Graphics functions include

* Rectangle Displays a rectangle.
* Panel Draws a rectangle with a black border and white inside.
* Outline Outlines a rectangle in black.
* ShadowBox Draws a Panel box with a shadow to the right and underneath.
* ClearRect Clears a section of the screen to white.
* Line Draws a line.
* RegisterFont Registers the given font as one of those which will be used by the application.
* SetDefaultFont Sets the default font.
* GetDefaultFont Returns the current default font.
* SetCurrentFont Sets the current system font.
* GetCurrentFont Returns the currently defined system font.
* SetMenuFont Sets the system font to be used for the menus.
* SetGlobalClipping Sets the master clipping against which all local clip regions are clipped.
* SetLocalClipping Sets clipping region within a particular window.
* GetLocalClipping Returns the currently defined local clipping region.
* IntersectLocalClipping Sets the Local clipping region to the intersection of the specified rectangular region and the currently defined Local clipping region.
* ShowSymbol Displays a special symbol at the given location.
* ResetVideo Resets the internal LHAPI video state variables.
* SetRepRule Sets the low-level graphics pixel replacement rule.
* ResetRepRule Sets the low-level graphics pixel replacement rule to default.
* SetHelpKey Sets the application-wide help key.

## LHAPI Structures

### LHWINDOW - Window Structure

The window is the basic unit of interface construction; at any one time, one window has focus and determines how keys are handled. The window also determines what menu and function keys are available. Either by itself or with other windows, this window creates the display presented to the user.

The application defines each of its windows in a Window structure. Most windows are completely defined before execution, but some, like menus and error messages, are filled in on the fly by LHAPI. All windows, whether filled in by the application or by LHAPI must be supplied by the application; LHAPI does not allocate any memory for window creation.

* **Class:** The class field is either a far code pointer to the class handler code for the window, or a long integer that is a handle into an internal table of LHAPI-provided base classes. The segment portion/high word of the long=0 indicates to LHAPI that the class is a built-in class.The LHAPI-provided base classes are described in detail in Chapter 7
* **x,y:** These values define the screen position of the upper-left corner of the window. If STYLE_XYRELATIVE is being used, then the signed values in these fields specify the relative pixel offset from the parent window's upper-left corner. When using STYLE_XYRELATIVE, the Object class handler converts the relative position of the window to the corresponding absolute position when it receives an APPEAR message, storing the resulting value in these same fields. The window's status bit STATUS_XY_ABSis set in this case. It then converts the position back when it receives a DISAPPEAR message (it looks at the STATUS_XY_ABS bit to determine whether or not to convert x and y back). If STYLE_XYRELATIVE is not being used, the x and y fields contain the absolute pixel position of the start of the window, which is not changed on APPEAR or DISAPPEAR messages.
* **w,h:** These fields define the size of window area. If STYLE_WHCHAR is being used, the values in these fields specify the size, in terms of text characters, of the client portion of the window only. In this case, each sub-class window handler is responsible for converting the window text character size to pixel size when it receives an APPEAR message, storing the resulting values in these same fields. Similarly to the STYLE_XYRELATIVE bit, during the APPEAR message, if the STYLE_WHCHAR bit is set, the STATUS_WH_PIXEL bit should be set to indicate the reverse translation needs to happen on the DISAPPEAR. (Each handler must then convert the size back again, if necessary, when it receives a DISAPPEAR message.) All of the LHAPI-provided window classes automatically perform these services. If STYLE_WHCHAR is not being used, the w and h parameters refer to pixel sizes, and are not touched during APPEAR/DISAPPEAR messages.
* **Title:** Title is a resource pointer (a near pointer to a far pointer to a string) that "names" the field for the user. Normally, this name will show on screen, but it is not required for all window types.
* **Data:** This field points to the data area that the window should modify. The meaning and format of this data area is different for each window.
* **LogicalSize:** The meaning of this field varies with the class it is describing.
* **Style:** This field is a word of bit flags. Styles for a window should be ORed together. Style consists of two parts: global styles that apply to all windows and local styles that apply to a specific window class.

The global window styles are:

#### STYLE_INVISIBLE (0x80000000L)

The window will not display itself. Although the built-in LHAPI classes handle this automatically, for user supplied classes, you must test for this bit before drawing if you wish to use it.

#### STYLE_SAVEUNDER (0x40000000L)

The window will save the background underneath the window during an APPEAR message, and restore it upon a DISAPPEAR, if there is enough room in LHAPI's screen save buffer. The buffer is 8K system-wide, and all window screen-saves(including LHAPI-owned menu windows) go into it. Although there is only one buffer, switching between apps causes LHAPI to re-APPEAR all the active windows, which regenerates the screen-save buffer. If there wasn't enough space on creating the window, the DISAPPEAR will handle the screen restore as it normally does, i.e., set global clipping and refresh all windows. See the DISAPPEAR message for more information.

#### STYLE_NOFOCUS (0x20000000L)

The window cannot receive the focus.

#### STYLE_NOTIFY (0x10000000L)

For a child window, this style tells the window to notify the parent when it changes state via NOTIFY_CHILDKILLED and NOTIFY_CHILDCHANGED messages.

#### STYLE_LEAF (0x08000000L)

For dialog controls or other terminal windows, this style prevents DESTROY messages from cascading any further down the window chain to child windows, and causes the Menu field in this LHWINDOW structure to be ignored.

Note: Only use STYLE_LEAF when safe. Improper use of STYLE_LEAF can destroy the window chain. The DialogBox handler automatically sets STYLE_LEAF in any child windows, so it is not necessary to explicitly employ it.

#### STYLE_NOBORDER (0x04000000L)

The window will be displayed without a border

#### STYLE_WHCHAR (0x02000000L)

The window size specified in the w and h fields is specified in terms of text characters, not pixels. In addition, the size specified includes only the client portion of the window, not any window title or border. LHAPI-provided base class handlers, except the Object handler, convert the window character size to the corresponding window pixel size when they receive a CREATE message. The STATUS_WH_PIXEL bit in the Status field gets set when the w and h are converted from character measurements into pixel measurements.

#### STYLE_XYRELATIVE (0x01000000L)

The window position specified in the x and y fields is relative to the parent window. If the STATUS_XY_ABS bit in the window Status field is not set, the Object class handler will convert the relative offset to the corresponding absolute display coordinates when it receives a CREATE message.

#### STYLE_GRAY (0x00800000L)

STYLE_GRAY indicates that the window should be displayed as gray. This style is used for dialog controls that should not be accessed.

#### STYLE_RADIO (0x00400000L)

This style is automatically set for RadioButton windows so that the DialogBox handler will correctly perform special handling for them.

#### STYLE_COMBOLIST (0x00200000L)

This style is set by the application in the window structure for the ListBox portion of a ComboBox. This style signals to the DialogBox handler not to CREATE this window when it automatically creates all the others in the dialog box control field array. The window is however, sent a DESTROY message when the dialog box itself is destroyed. This style should be used if the window structure for the listbox portion of a comboxbox is defined in the dialog control field array.

#### STYLE_PUSHBUTTON (0x00100000L)

This needs to be set so that the DialogBox handler will correctly perform special pushbutton handling. Note that the application is responsible for setting this bit, as it will not be set by the PushButton handler. The reason for this is that the DialogBox handler looks at this bit before the PushButton handler would get an opportunity to set it.

#### STYLE_PUSHB_WIDTH (0x00080000L)

This style is Set by an application if it wants the DialogBox handler to automatically calculate and set the width of each of the PushButtons in the dialogbox. The pushbutton width will be calculated based on the longest label that will appear in any of the pushbuttons. Note that this Style bit is to be set in the DialogBox window structure, not each of the PushButton window structure.

#### STYLE_NO_PARENT_KEY (0x00040000L)

Object will not send any unused keystrokes it receives to a window's Parent. This bit is usually temporarily set by a window handler before it passes keystrokes on to Object in order to allow Object to check for menu or function keys, but does not allow it to do anything else.

#### STYLE_CHECKBOX (0x00020000L)

This style is automatically set for CheckBox windows so that the DialogBox handler will correctly perform special handling for them.

#### STYLE_DATETIME (0x00001000L)

This style is automatically set by the DateTime window handler so that the displayed date and time can be kept updated to the current system date & time.

#### STYLE_COMBOEDIT (0x00008000L)

This style is automaticlly set by the ComboBox handler to signal that the combobox LHWINDOW structure is actually the window structure for the edit portion of the combobox.

#### STYLE_NOSHADOW (0x00004000L)

In DialogBoxes and MessageBoxes, the window border will be drawn without a shadow around it.

Local window styles are described with each base class description in chapter 7.

* **Parent:** This field specifies the window that "owns" this window. The parent relationship is used to
  1. Send messages that are not understood back through the chain of windows.
  2. Stack menus and function keys.
  3. Provide levels of windows that can be acted upon all at once. By destroying a parent window, all its children are destroyed.

* **Fkey:** This field points to an FKEYS structure that defines the active function keys if this window gets the focus. Other acceptable values are PARENT_FKEYS and NO_FKEYS. PARENT_FKEYS means "look to my parent window for function-key definitions," and NO_FKEYS means that no function keys are supplied.
* **Menu:** Menu points to the array of MENU structures which will be activated by pressing the MENU key, PARENT_MENU, or NO_MENU. PARENT_MENU means "look at my parent for a menu," and NO_MENU disables the menu.

Note that for dialog controls (or any other windows with the STYLE_LEAF bit set) the Menu field is ignored, and the parent's menu is looked at automatically.

* **Help:** Help gives the help screen number, which is used to show context-sensitive help. A value of NO_HELP means that this window does not have any help text associated with it.
* **Status:** Status gives the byte for window status. Used by Edit control for insert/overwrite and First Key flag, and reserved for other windows. The following status bits are globally defined bits. Application-defined window handlers may use the rest of the status bits for their own use.

#### STATUS_VISIBLE

(0x80) This style is set when the window is currently being displayed on the screen.

#### STATUS_SAVEUNDER

(0x40) This style is set when the display image underneath the window was saved in an internal LHAPI buffer.

#### STATUS_XY_ABS

(0x20) This style is set when the x and y fields are converted from a relative offset from the parent window to the corresponding absolute display coordinates (when STYLE_XYRELATIVE is being used).

#### STATUS_WH_PIXEL

(0x10) This style is set when the w and h fields are converted from text-character based to pixel based (when STYLE_WHCHAR is being used).

#### STATUS_INCREATE

(0x08) This style is set by the Object class handler before issuing a SETFOCUS message as part of the CREATE_FOCUS message processing. This is used by window handlers that need to differentiate this case from the other times it can receive a SETFOCUS message.

#### STATUS_NOT_EDITED

(0x04) If this style is set, data has yet to be edited. This style is cleared each time the Edit window is used in some way.

* **Selection:** Selection gives the current cursor selection. This means different things in different windows. For Edit windows, Selection is the cursor position, for list boxes and combo boxes, it is the current line.
* **WindowTop:** The top of the area being displayed. For single-line scrolling edit windows, it is the first character to show in the window. For multi-line edit windows, it is the first line to show in the box. For list boxes, WindowTop is the first string showing at the top of the box, etc.
* **Font:** Font is a bitmapped ID of the default font type for this window. This is the font type ID, which LHAPI will use for all of the drawing which it does within this window (also used by the DrawText service). The high byte of Font is the width of the font in pixels while the low byte is the height of the font. The possible values are:

#### FONT_DEFAULT

(0) Use the whatever the currently selected default font is (as specified by a prior call to SetDefaultFont) when the window is DRAWn. This use of FONT_DEFAULT does not hold true for the TitleBar window class, which will always use FONT_SMALL, unless a particular font type is specified in the titlebar window structure.

#### FONT_PARENT

(1) Use the same font the window's Parent is using.

FONT_SMALL , FONT_NORMAL, and FONT_LARGE use the specified font, as defined below:

FONT_SMALL_W 8

FONT_SMALL_H 8

FONT_SMALL (FONT_SMALL_W<<8) + FONT_SMALL_H

FONT_NORMAL_W 10

FONT_NORMAL_H 11

FONT_NORMAL (FONT_NORMAL_W<<8) + FONT_NORMAL_H

FONT_LARGE_W 16

FONT_LARGE_H 12

FONT_LARGE (FONT_LARGE_W<<8) + FONT_LARGE_H

* **NextWnd,PrevWnd:** These are internally maintained pointers to the next or previous window in the window list. They are used by LHAPI to traverse the list.

### Menu Structure

An application menu is an array of menu structures in which each structure describes one menu item. The top menu and each popdown menu are seperate arrays. Each array must end with a menu structure filled with 0

* **Title:** Title is the displayed name of the item. Characters preceded by "&" specify the menu item's mneumonic and appear underlined.
* **Handler:** For pull-down menus, Handler is a near pointer to a menu structure. For menu actions other than pull-downs, Handler is either a near pointer to code associated with the menu item or an integer ID number. For window creations, this field is a near pointer to a window structure. (See Style below). A summary of the available choices for menu actions:
  * Direct launch of function. Don't set the MENU_SENDMSG, MENU_PULLDOWN, or MENU_CREATEWND style bits. Handler is the address of the function to execute.
  * Creation of a pull-down menu. Set the MENU_CREATEWND style bit. Handler is the address of the pull-down menu structure array.
  * Creation of a dialog/window. Set the MENU_CREATEWND style bit. Handler is the address of the window to create (a LHWINDOW struct).
  * Send a command message. Set the MENU_SENDMSG style bit. Hander is the integer ID of the COMMAND you want to execute (the Data word of the incoming COMMAND message).
* **HotKey:** This field is the scancode of key that will execute the function directly without going through the menu.
* **Style:** Style bits are defined as follows:

**MENU_GRAY**

**MENU_INVISIBLE**
0x0040 The menu item doesn't display. MENU_INVISIBLE is used to support different menu choices embedded in the same menu structure.

**MENU_CHECKED**
0x0020 The menu item displays with a check mark before it.

**MENU_BARBEFORE**
0x0010 A separator bar is inserted before the item.

**MENU_SENDMSG**
0x0008 Instead of the handler being directly called by the menu system, a COMMAND message is sent to the menu's parent window, with the Data parameter set to the LHMENU Handler field. This allows the flexibility of placing code inside a switch, and lets a window handler manage menu options that may be modal in that window.

**MENU_PULLDOWN**
0x0004 The menu is a pop-down menu. The handler points to the array of pop-down menu structures.

**MENU_CREATEWND**
0x0002 The handler is a pointer to a window structure; this window is automatically created and given the focus (via a CREATE, CREATE_FOCUS, SETFOCUS_NORMAL message) when the corresponding menu item is selected. This would typically be a DialogBox, but it does not have to be.

**MENU_ELLIPSIS**
0x0001 This field appends the "..." text string to the menu item when displayed to indicate a dialog is initiated by that menu item.

**MENU_USER**
0x0400 Values of the Style field at and after this value are reserved for application-specific uses.

* **Help:** Help is the context-sensitive help index number for this menu item. A value of NO_HELP means that this menu item does not have any help text associated with it.

### FKEY - Function key structure

Function key sets are compressed; only the function keys that have definitions need to be present. The KeyNum field indicates which function key the definition is for.

Valid numbers are

* 1..12.
* FKEY_SHIFT + (1..12).
* FKEY_ALT + (1..12).
* FKEY_CTRL + (1..12).

The last function key in the set should have FKEY_LAST added to it's function key number.

### LHAPIBLOCK - Application Window Management Structure

Each application must define one LHAPIBLOCK with which LHAPI keeps track of that application's windowing. LHAPI is notified of the block's location during application initialization, and after context switching back to the application.

The application itself should not modify or peek into the structure of the LHAPIBLOCK, as the LHAPIBLOCK structure is subject to change. If the application needs information, it should get it through calls to LHAPI functions.

* **FirstWnd:** This gives the first window in the LHAPI window list. LHAPI can traverse all windows by starting at FirstWnd, and following the window's NextWnd pointer. If a window's NextWnd pointer is NULL, the end of the list has been reached.
* **LastWnd:** This gives the last window in the window list. If windows are added to the screen, they are chained on to this LastWnd.
* **FocusWnd:** FocusWnd is the window that has focus, i.e. will get user keystrokes.
* **BeginHighlight:** BeginHighlight points to the beginning of the highlighted (user-selected) area to be cut/copied/pasted/overwritten/deleted. This may mean different things to different window classes, but it is reset by LHAPI each time a different window receives the focus. For edit windows, this is the offset into the edit data buffer of the first text character which is highlighted.
* **EndHighlight:** Similar to BeginHighlight, EndHighlight indicates end of highlight. For edit windows, this is the offset into the edit data buffer of the character immediately following the last text character which is highlighted. Thus, the number of characters highlighted is (EndHighLight - BeginHighlight), with nothing highlighted if (EndHighLight = BeginHighlight).
* **Status:** LHAPIBLOCK Status Field bit defintions are

**STATUS_ALT_MENU**

**STATUS_ALT_PRESS**
0x0002 This bit is the flag for last shift state of the \<Alt\> key: 0=Up, 1=Pressed.

This bit is set when the \<Alt\> key is pressed (make) and cleared when the \<Alt\> key is released (break).

**STATUS_SHIFT_PRESS**
0x0004 This bit is the flag for last shift state of the \<Shift\> key: 0=Up, 1=Pressed.

This bit is set when a \<Shift\> key is pressed (make) and cleared when a \<Shift\> key is released (break). Note that these values are set according to what the BIOS tells us. If the BIOS implements a "sticky" key, we do not actually realize that the key has been released until the next key has been struck and the BIOS tells us then that the prior keys has been released.

**STATUS_CTRL_PRESS**
0x0008 This bit is the flag for last shift state of the \<Ctrl\> key: 0=Up, 1=Pressed.

This bit is set when the \<Ctrl\> key is pressed (make) and cleared when the \<Ctrl\> key is released (break).

**STATUS_CAPSLOCK**
0x0010 This bit is the flag for the current state of \<CapsLock\>: 0=Off, 1=On.

This bit is set when the CapsLock state toggles on, and cleared when the CapsLock state toggles off.

**STATUS_SCROLLLOCK**
0x0020 This bit is the flag for the current state of \<ScrollLock\>: 0=Off, 1=On.

This bit is set when the ScrollLock state toggles on, and cleared when the ScrollLock state toggles off.

**STATUS_KEYPAD_PRESS**
0x0040 This bit is the flag which is set when the user presses an \<Alt-UpArrow\> or an \<Alt-DownArrow\> keystroke in a ComboBox. The subsequent \<Alt-NumberPad\> scan code which will be generated by the BIOS will then be ignored.

**STATUS_EDIT_UNDO**
0x0080 This bit is the flag which signals whether or not the edit text has been modified since the edit window received the focus (1=modified; 0=unchanged). If this bit is set, the next \<Esc\> key press will cause the original copy of the edit text to be restored from the save buffer.

**STATUS_SUBMENUS**
0x8000 This bit is the set when the sub-menus below the top menubar items are displayed while the user navigates through the top menubar items. This is needed when the menubar item selection is moved from an item that has a sub-menu to one that doesn't. In this case, the appropriate sub-menu will automatically be activated by LHAPI when the top menubar selection returns to an item that has a sub-menu.

* **UndoBuffer:** This buffer is used in a one-level undo of edit text. A default UndoBuffer is allocated by LHAPI. An application can define a larger buffer by allocating one itself and passing it to the SetUndoBuffer service.
* **FkeyPtr:** This field points to current FKey structure so that the LHAPI can determine whether or not to redisplay the function keys.
* **ScreenSave:** This is a far pointer to screen stack area, which is set by InitializeLHAPI. The Screen stack is used by Object to save the contents of the screen underneath windows that employ STYLE_SAVEUNDER. This buffer is allocated by LHAPI itself. Once this pointer is initialized, it is never changed.
* **ScreenSaveStart:** ScreenSaveStart is the offset into the ScreenSave buffer of the next available memory. It is used by Object to maintain the Screen stack for windows that employ STYLE_SAVEUNDER. This index is updated every time a screen is saved or restored.
* **ScreenSaveEnd:** Total size, in bytes, of the ScreenSave buffer. It is used by Object to maintain the screen stack for windows that employ STYLE_SAVEUNDER. Once this index is set by InitializeLHAPI, it is never changed.
* **ErrorNum:** This field gives the error number with which to create error window.
* **ErrorHandler:** This field gives the routine to be executed by Error functions.
* **TopMenuWnd:** The window structure for top level menu window, this field gets automatically filled in when menu key is intercepted. Although LHAPI fills in this window structure when the menu comes up, the Handler field is left alone if it is non-null. This allows you to subclass the menu by putting in your own menu handler.
* **PopMenuWnd:** The window structure for popdown menu window, this field is filled in by the menu window class handler when traversing the menus. Although LHAPI fills in this window structure when the menu comes up, the Handler field is left alone if it is non-null. This allows you to subclass the menu by putting in your own menu handler.
* **CurrentDialog:** PLHWINDOW points to the current dialog if one is created.
* **DefaultFont:** This field gives the ID of the currently defined "default" application font to be used in windows that specify a font type of FONT_DEFAULT. This field is set by the SetDefaultFont service.
* **HelpFkey:** The keycode of the application-defined "Help" function-key sequence, this field is used internally by LHAPI and is set via the SetHelpFKey service. If an application does not explicitly set the help key, the default of \<F1\> is used.

### LHEDITDATA - Multi-Line Edit Window Data Field Structure

This structure contains the definition of the LHWINDOW Data field for a Multi-line Edit window. This structure is needed because the standard LHWINDOW structure is not sufficient for use by the LHAPI-provided multi-line edit class handler. All the fields specified in the LHWINDOW structure are still valid and used in a multi-line edit window.

* **Buffer:** This field points to the text data buffer, in RAM, which will actually be edited.
* **SaveBuffer:** This field points to the data buffer in which a copy of the original edit text will be saved when the user begins editing it, and from which it will be restored when the user presses the \<ESC\> key. If this pointer is set to NULL, the original edit text will not be saved anywhere by LHAPI, and thus it also cannot be restored by it.
* **LineStarts:** This field is the indirect pointer to the array which will hold the offset into the edit text buffer of the start of each of the lines in the buffer. If all of the available entries in this array are used, the user will be unable to enter any data past the end of the last line. An entry in this array is used for each line, regardless of whether or not that line is currently visible on the screen (the multi-line edit buffer can contain more data than is visible at any one time with the edit window being scrollable up and down). These fields are initialized and maintained by the LHAPI multi-line edit handler.
* **MaxLines:** The maximum number of lines in the entire edit buffer, this number differs from the number of lines which is seen in the edit window at any one time. This field is also the total size, in entries, of the LineStarts array.
* **WrapLen:** WrapLen is the number of text characters at which to word wrap each line in the multi-line edit window. If this field is initialized to 0 by an application before a CREATE message is issued, LHAPI will automatically adjust it to the total width of the multi-line edit window box. The word wrap can be changed on the fly by an application by first updating this field to the desired value and then issuing a NOTIFY,NOTIFY_UPDATE message to the multi-line edit window handler.
* **CurrentLine, CurrentCol:** These fields define the line and column, relative to the start of the edit data text, the cursor is currently on. A line and column of 0,0 signifies that the cursor is currently on the first character in the edit data buffer. These fields are initialized and maintained by the LHAPI multi-line edit handler.
* **NumLines:** This field indicates the number of lines of data currently in the edit buffer. NumLines has a value in the range of 1 to MaxLines and is initialized and maintained by the LHAPI multi-line edit handler.
* **TextLen:** This field gives the length, in characters, of the text string being edited, not inluding the null-termination character at the end the edit text string. TextLen also represents the character offset into the edit buffer of the null-terminator. This field is initialized and maintained by the LHAPI multi-line edit handler.

## Messages

Messages are the way programs communicate with the various classes of window. Window classes in LHAPI and in the application are treated identically. Since all windows do not respond to all messages, those messages that are not acknowledged should be passed on to the parent class.

Note that although not all messages have a meaningful return value, return values are provided for windows to give feedback to the caller. This happens for DESTROY, LOSEFOCUS, and other messages that the window may wish to reply to; these two messages allow a FALSE return value to abort the process. The return value TRUE is used for most messages.

Messages have optional components, Data and Extra, that are needed in some cases to give specifics about the type/meaning of the sent message. This would be a key character for KEYSTROKE, a command number for COMMAND, etc.

The messages are:

* KEYSTROKE: Sent to the focus window when a key is pressed.
* DRAW: A message for the window to redraw itself. The Data field is set to an bit mask indicating the requested draw area. See the DRAW_ submessages below.
* CREATE: To create a window, a CREATE message is sent to that window.
* DESTROY: To destroy a window, a DESTROY message is sent to that window
* TERMINATE: Sent to all windows when the application is terminated.
* ACTIVATE: Sent to all windows when returning from a context switch.
* DEACTIVATE: Sent to all windows when the app is being switched away.
* SETFOCUS: Sent to the window that is going to get the focus. The message's Data field can be set to SETFOCUS_SELECT to force the window to respond with an implicit selection (i.e. "check" itself).
* LOSEFOCUS: Sent to the window about to lose the focus. This is automatically done by the system when another window receives a SETFOCUS message.
* NULL: Sent for E_NONE or "NULL" messages. The type of E_NONE event is specified in the Data fieldsee NULL_ submessages below.
* NOTIFY: Used to notify either the child or parent window. The Data field is set to the submessage; see NOTIFY_ messages below.
* COMMAND: Sent to a window that doesn't register a menu or function key handler and uses FKEY/MENU_SENDCOMMAND style bit.
* APPEAR: Sent to a window to make it visible. If the window is employing the STYLE_SAVEUNDER style, and there is enough room in the LHAPI screen save buffer, the area underneath the window defined by (x,y)-(x+w-1,y+h-1) is saved with a GetImage.
* DISAPPEAR: Send to a window to make it invisible. If the window is employing the STYLE_SAVEUNDER style, and the area underneath the window was saved on the APPEAR message, the area underneath the window defined by (x,y)-(x+w-1,y+h-1) is restored with a PutImage.

### Submessages

All submessages are passed to window handlers via the Data parameter.

#### CREATE Submesssages

* CREATE_NORMAL (0): The window is created normally, that is, it is is not sent a SETFOCUS message by the Object class handler.
* CREATE_FOCUS (1): The Object handler will automatically send a SETFOCUS message to the window after it is created. If the tertiary-message (the Extra parameter of the window handler inputs) is not SETFOCUS_NOLOSE, then the previous focus window will be sent a LOSEFOCUS message before the new window is sent the APPEAR message. This is to allow, for instance, the previous focus window to redraw part of it's window area in order to show that it no longer has the focus before the new window is drawn, thereby preventing the possibility that part of the new window will be overwritten by the previous focus window. The possible values for the Extra parameter of the CREATE message are the same as the SETFOCUS submessages (see the SETFOCUS submessages description for more information about these sub-messages).

#### DESTROY Submessages

* DESTROY_NORMAL (0): The window is destroyed normally in that the Object class handler will cause all the other windows currently visible to be redrawn if this window does not employ STYLE_SAVEUNDER. It accomplishes this by sending a DISAPPEAR_NORMAL message to this window's handler.
* DESTROY_NODRAW (1): The Object class handler will send a DISAPPEAR_NODRAW message to the window in order to prevent all the other visible windows from being redrawn (if STYLE_SAVEUNDER is not being used). This is useful when a parent window (such as a dialog box) is destroyed, in which case we want to prevent all of it's child windows from causing all the other visible windows from being redrawn when each of them is destroyed.

#### DISAPPEAR Submessages

* DISAPPEAR_NORMAL (0): If the window is not employing the STYLE_SAVEUNDER style, the Object class handler will send a DRAW_ALL message to all the other active, visible windows in order to remove this window from the screen. If the window is employing the STYLE_SAVEUNDER style, and there was enough room in the LHAPI screen save buffer to save the window on APPEARING, the area underneath the window is restored.
* DISAPPEAR_NODRAW (1): If the window is not employing the STYLE_SAVEUNDER style, the Object class handler will NOT send a DRAW_ALL message to all the other active, visible windows. This is useful when each of the children of a parent window is sent a DISAPPEAR message.

#### NOTIFY Submessages (Passed in Data)

* NOTIFY_CHILDKILLED (0): This submessage is sent to a parent window when a child is killed if it needs to report something in particular. NOTE: the Window parameter which the parent window's handler receives actually points to the child window that was destroyed. Normally, this points to the window itself.
* NOTIFY_UPDATE (1): This submessage is sent to a window handler by an application to tell the window to notice a change in its data. This forces the handler to reinitialize any pertinent variables and redraw itself.
* NOTIFY_CHILDCHANGED (2): This submessage is sent to a parent window when a child changes state. In this way the parent can keep track of a child window's processing. Note that the extra parameter of this message is set to the address of the child window's LHWINDOW structure.
* NOTIFY_SORT (3): This submessage is sent to ListBox windows to have them sort their contents. The extra field specifies the sort order (=0 : ascending, !=0 : descending). The window redraws itself as a result.
* NOTIFY_USER (256): Any applicaton defined submessages should have values starting at NOTIFY_USER. Application defined submessages can be used for inter-window communications, i.e., as a way for various window handlers to converse with one another.

#### COMMAND Submesssages

These values are usually set as the command code in PushButton LHWINDOW structures in order to get the DialogBox handler to recognize common actions. To get LHAPI to send COMMAND messages by "clicking" pushbuttons, you must set the PUSHB_SENDMSG style for those pushbuttons.

* CMD_DONE (0): This submessage is only recognized by the DialogBox handler, in which case it will automatically send the dialogbox window a (KEYSTROKE, F10, 0) message.
* CMD_ESC (1): This submessage is only recognized by the DialogBox handler to automatically DESTROY itself.
* CMD_DIALOGFOCUS (2): This submessage is only recognized by the DialogBox handler to set the focus to the dialog control corresponding to the field value specified in the Extra parameter.
* CMD_PUSHB_ACTIVATE (3): This submessage is sent to PushButton windows to have them activate themselves and perform the application-specified action.
* CMD_USER (256): Any applicaton-defined submessages should have values starting at CMD_USER.

#### DRAW Submessages

DRAW is a bitmask value passed in the Data parameter. To display multiple regions of the window, OR the bit values for the desired window regions together. To prevent a region from being drawn, AND out the particular bit representing that region. Note that not all DRAW_ regions make sense for all windows.

* DRAW_TITLE: This submessage draws the window title. (0x0001 = 0000 0000 0000 0001)
* DRAW_FKEYS: This submessage draws the function keys bar. This sub-message is managed entirely by the Object class handler. It is sent by Object when a different window receives the focus. (0x0002 = 0000 0000 0000 0010)
* DRAW_CLIENT: This submessage draws the entire window client area or workspace. (0x0004 = 0000 0000 0000 0100)
* DRAW_CLIENT_UPDATE: This submessage draws that portion of the window client area which is after the current cursor position (as defined by the Selection field in the LHWINDOW structure). This message is used, for instance, when text in an edit window is deleted or inserted. In this case, the deleted/inserted text should be removed/added to the edit buffer before this message is sent. (0x0008 = 0000 0000 0000 1000)
* DRAW_CLIENT_CHAR: For edit windows, this submessage draws only the character at the current cursor position. (0x0010 = 0000 0000 0001 0000)
* DRAW_FRAME: This submessage outlines the window by displaying the window frame. (0x0020 = 0000 0000 0010 0000)
* DRAW_CURSOR: This submessage shows the window's cursor. (0x0040 = 0000 0000 0100 0000)
* DRAW_USER: Any applicaton defined areas should be bits starting at DRAW_USER. (0x0100 = 0000 0001 0000 0000)
* DRAW_ALL: This submessage is a mask for all regions of the window (DRAW_CLIENT_UPDATE and DRAW_CLIENT_CHAR are not included, since these are subsets of DRAW_CLIENT). This message is automatically sent by the Object class handler when a window is created. (0xFFE7 = 1111 1111 1110 0111)

#### SETFOCUS Submesssages

* SETFOCUS_NORMAL (0): A LOSEFOCUS message is sent to the old focus window after the new focus window receives this SETFOCUS message.
* SETFOCUS_NOLOSE (1): This submessage supresses a LOSEFOCUS message being sent to the old focus window.
* SETFOCUS_SELECT (2): The window receives the focus, and does an implicit selection. This submessage is only used for CheckBoxes, and is equivalent to pressing \<Space\> immediately after the checkbox receives the focus.

#### LOSEFOCUS Submesssages

* LOSEFOCUS_NORMAL(0): The LOSEFOCUS message was sent under normal circumstances.
* LOSEFOCUS_MENU (1): The LOSEFOCUS message was sent prior to a menu window being created and given the focus. This is provided in order to allow a window handler to behave differently depending on whether or not a LOSEFOCUS message is received because the menus are being activated.

## Call Descriptions

### ClearError

This function clears both the ErrorNum and Handler fields in the LHAPIBLOCK structure.

* Syntax: void DISTANCE ClearError(void)
* Parameters: None
* Returns: None

### ClearRect

This function clears a section of the screen to white and exits with COLOR=COLOR_NORMAL. All parameters are in pixels. (0,0) is the upper-left corner of the screen.

* Syntax: void DISTANCE ClearRect(int x, int y, int w, int h)
* Parameters:

```
    int x   Horizontal location of upper left corner of cleared area.
    int y   Vertical location of upper left corner of cleared area.
    int w   Width of cleared area.
    int h   Height of cleared area.
```

* Returns: None

### DeactivateLHAPI

The application tells LHAPI that it is switching out. This sends a DEACTIVATE message to all the applications open windows. Note: If you DeactivateLHAPI and LHAPI doesn't think you are the current application, you are likely to lock up. See the note underneath UninitializeLHAPI.

* Syntax: void DISTANCE DeactivateLHAPI(void)
* Parameters: None
* Returns: None

### DrawChar

This function displays a single character on the screen at the given location and in the specified Draw style and font.

* Syntax: UINT DISTANCE DrawChar(int x, int y, UCHAR CharCode, UINT Style, UINT Font)
* Parameters:

```
    int x                Horizontal location of the character.
    int y                Vertical location of the character.
    UCHAR CharCode       Character to be displayed.
    UINT Style           Style for the character.
    UINT Font            Font for the character.
```

* Returns: The width of the displayed character, in pixels.
* Comments: The supported drawing styles are:

The supported font values are
FONT_DEFAULT. The current font setting.
FONT_SMALL. The 8x8 font.
FONT_NORMAL. The 10x11 font.
FONT_LARGE. The 16x12 font.

### DrawFKeys

This function displays the function key labels for the given window at the bottom of the display.

* Syntax: void DISTANCE DrawFKeys(PLHWINDOW Window, UINT ShiftState)
* Parameters:

UINT ShiftState: Refers to the "shift" (\<Ctrl\>, \<Alt\>, \<Shift\>) key state to display the defined function keys for. ShiftState uses the same values as those previously defined for the KeyNum field the LHFKEY structure and are:
FKEY_ALONE.
FKEY_CTRL.
FKEY_ALT.
FKEY_SHIFT.

* Returns: None

### DrawNChars

This function similar to DrawText, except that MaxChars specifies the maximum number of characters in the text string to display. If the total string length is greater than MaxChars, only the first MaxChars characters will be displayed.

* Syntax: UINT DISTANCE DrawNChars(int x, int y, char _far *Buffer, UINT Style,UINT Font, UINT MaxChars)
* Parameters:

```
    int x                   Horizontal location of the starting character.
    int y                   Vertical location of the starting character.
    char _far *Buffer       Pointer to buffer containing the string to be displayed.
    UINT Style              Style for the text.
    UINT Font               Font for the text.
    UINT MaxChars           Maximum number of characters in the text string to display.
```

* Returns: The width of the displayed string, in pixels.
* Comments: The supported drawing styles are:

```
    DRAW_NORMAL.        The charactersare drawn as black on a white background.
    DRAW_INVERSE.       The characters are drawn as white on a black background.
    DRAW_UNDERLINE.     The characters are drawn underlined.
    DRAW_GRAY.          The characters are drawn in "gray", i.e. a checkerboard
                        mask is ANDed over the characters.
    DRAW_AMPERSAND.     Any "&"s in the string underline the following character
```

The supported font values are

```
    FONT_DEFAULT.       The current font setting.
    FONT_SMALL.         The 8x8 font.
    FONT_NORMAL.        The 10x11 font.
    FONT_LARGE.         The 16x12 font.
```

### DrawText

This function draws text on the screen using the Style word. If the Buffer pointer is NULL, or the string starts with a null-terminator, this routine returns without displaying anything. The pointer can be considered NULL in one of two ways: either the entire pointer (both the segment and offset address parts) is set to NULL; or the offset portion of the pointer is NULL and the segment portion is set to the application's default data segment. The latter method is provided in order to validate near pointers which are "cast" to far pointers by compilers.

The text displayed is one line only, and is terminated by a NULL.

* Syntax: UINT DISTANCE DrawText(int x, int y, char _far *Buffer, UINT Style, UINT Font)
* Parameters:

```
    int x               Horizontal location of the starting character.
    int y               Vertical location of the starting character.
    char _far *Buffer   Pointer to buffer containing the string to be displayed.
    UINT Style          Style for the text.
    UINT Font           Font for the text.
```

* Returns: The width of the displayed string, in pixels.
* Comments: The supported drawing styles are:

```
    DRAW_NORMAL.        The charactersare drawn as black on a white background.
    DRAW_INVERSE.       The characters are drawn as white on a black background.
    DRAW_UNDERLINE.     The characters are drawn underlined.
    DRAW_GRAY.          The characters are drawn in "gray", i.e.  a checkerboard mask
                        is ANDed over the characters.
    DRAW_AMPERSAND.     Any "&"s in the string underline the following character.
    DRAW_TAB_TERM.      The <Tab> character (0x09) is considered a string terminator.
                        Like the null-termination character (0x00), all characters up to it
                        are displayed.
```

The supported font values are

```
    FONT_DEFAULT.       The current font setting.
    FONT_SMALL.         The 8x8 font.
    FONT_NORMAL.        The 10x11 font.
    FONT_LARGE.         The 16x12 font.
```

### GetCurrentFont

This function returns the currently defined system font (see SetCurrentFont()). This service will only be used when an application directly calls the low-level graphics layer rather than using the **DrawText** or **DrawChar** services to output text to the display.

The possible return values are FONT_SMALL, FONT_NORMAL, and FONT_LARGE.

* Syntax: UINT DISTANCE GetCurrentFont(void)
* Parameters: None
* Returns: Current system font value.

### GetDefaultFont

This function returns the current default font (see SetDefaultFont()). The possible return values are FONT_SMALL, FONT_NORMAL, and FONT_LARGE.

* Syntax: UINT DISTANCE GetDefaultFont(void)
* Parameters: None
* Returns: Current default font value.

### GetError

* Syntax: int DISTANCE GetError(void)
* Parameters: None
* Returns: ErrNum

### GetErrorHandler

This function gets the current error handler.

* Syntax: PLHFUNC DISTANCE GetErrorHandler(void)
* Parameters: None
* Returns: Pointer to the error handler function currently in use.

### GetFocus

This function returns a pointer to the current window with focus.

* Syntax: PLHWINDOW DISTANCE GetFocus(void)
* Parameters: None
* Returns: Pointer to the current window with focus.

### GetLHAPIBlockPtr

This function returns the offset address of the currently defined LHAPIBLOCK structure.

* Syntax: LHAPIBLOCK * DISTANCE GetLHAPIBlockPtr(void)
* Parameters: None
* Returns: The offset address of the currently defined LHAPIBLOCK structure.

### GetLocalClipping

This function returns the currently defined local clipping region.

* Syntax: void DISTANCE GetLocalClipping(int \*x1, int \*y1, int \*x2, int \*y2)
* Parameters:

```
    int *x1     Pointer to horizontal location of the upper left corner of the local clipping region.
    int *y1     Pointer to vertical location of the upper left corner of the local clipping region.
    int *x2     Pointer to horizontal location of the lower right corner of the local clipping region.
    int *y2     Pointer to vertical location of the lower right corner of the local clipping region.
```

* Returns: None

### InitializeLHAPI

This function is a first-time initialization by applications to point to a LHAPIBLOCK structure allocated by the application.

* Syntax: void DISTANCE InitializeLHAPI(LHAPIBLOCK *LHAPIData)
* Parameters: *LHAPIData Pointer to the application's LHAPI block. All information LHAPI needs to track for the current application is stored in the LHAPI block.
* Returns: None
* Comments: This service sets the current font type to FONT_NORMAL.

### IntersectLocalClipping

This function sets the Local clipping region to the intersection of the specified rectangular region and the currently defined Local clipping region.

* Syntax: void DISTANCE IntersectLocalClipping(int x1, int y1, int x2, int y2)
* Parameters:

```
    int x1     Horizontal location of the upper left corner of the local clipping region
    int y1     Vertical location of the upper left corner of the local clipping region.
    int x2     Horizontal location of the lower right corner of the local clipping region
    int y2     Vertical location of the lower right corner of the local clipping region.
```

* Returns: None

### Line

This function draws a line from x1,y1 to x2,y2 and exits with COLOR=Color.

* Syntax: void DISTANCE Line(int x1, int y1, int x2, int y2, UINT Color)
* Parameters:

```
    int x1      Horizontal location of starting pixel of line.
    int y1      Vertical location of starting pixel of line.
    int x2      Horizontal location of ending pixel of line.
    int y2      Vertical location of ending pixel of line.
    UINT Color  Color of line to be drawn.
```

* Returns: None

### Outline

This function outlines a rectangle in black, but does not change the inside. Outline exits with COLOR=COLOR_NORMAL.

* Syntax: void DISTANCE Outline(int x, int y, int w, int h)
* Parameters:

```
    int x      Horizontal location of upper left corner of rectangle.
    int y      Vertical location of upper left corner of rectangle.
    int w      Width of rectangle.
    int h      Height of rectangle.
```

* Returns: None

### Panel

This function draws a rectangle with a black border and white inside and exits with COLOR=COLOR_NORMAL.

* Syntax: void DISTANCE Panel(int x, int y, int w, int h)
* Parameters:

```
    int x      Horizontal location of upper left corner of rectangle.
    int y      Vertical location of upper left corner of rectangle.
    int w      Width of rectangle.
    int h      Height of rectangle.
```

* Returns: None

### ReactivateLHAPI

Using this function, the application reestablishes LHAPI's LHAPIBLOCK data structure after being switched back in. This routine first sends a REACTIVATE message to all the currently defined windows, followed by an APPEAR message.

* Syntax: void DISTANCE ReactivateLHAPI(LHAPIBLOCK *LHAPIData)
* Parameters: *LHAPIData Pointer to the application's LHAPI block (should be the same block that was called for InitializeLHAPI).
* Returns: None
* Related Calls: DeactivateLHAPI(), SendAllMsg()
* Comments: ReactivateLHAPI() actually makes a SendAllMsg(APPEAR, 0, 0) call.

### Rectangle

This function draws a rectangle using the specified color and flags and exits with COLOR=Color.

* Syntax: void DISTANCE Rectangle(int x, int y, int w, int h, UINT Color, UINT Flags)

* Parameters:

```
    int x        Horizontal location of upper left corner of rectangle.
    int y        Vertical location of upper left corner of rectangle.
    int w        Width of rectangle.
    int h        Height of rectangle.
    UINT Color   Color to be used as identified by Flags setting.
    \UINT Flags  0 = Outline only
                 1 = Solidfill interior
                 2 = Patternfill interior with "gray" pattern
```

* Returns: None

### RegisterFont

This function registers the given font as one of those which will be used by the application. This routine is used by LHAPI to arrange the font bitmap stack such that the fonts to be used by an application are on the top of the stack, thereby avoiding the problem of fonts being constantly removed and added to the bitmap stack. This service should be called immediately after InitializeLHAPI().

If FONT_DEFAULTS is not used, RegisterFont must be called for each font that will be used by the application (including the menu font).

* Syntax: void DISTANCE RegisterFont(UINT Font)
* Parameters: UINT Font Font value to be added to the font bitmap stack. The possible Font values are:

```
    FONT_DEFAULTS      - causes all of the default system
                       fonts-FONT_SMALL, FONT_NORMAL FONT_LARGE (if there's enough
                       room) - to be placed on the font bitmap stack.
    FONT_SMALL
    FONT_NORMAL
    FONT_LARGE
```

* Returns: None

### ResetAlt

Any internal LHAPI functions that process the Alt key, call ResetAlt to prevent the Alt release from generating a menu. If you need to trap Alt key presses/releases, you need to call ResetAlt so that if the Alt release scan code gets to Object, you won't get an unwanted menu.

In order for the Alt=Menu processing to work in the first place, the System Manager takes over int 15, func 4F, to intercept Alt, Shift and Control. Additional scancodes are generated for these shift keys so that LHAPI can recognize key make/break states. Normally, the BIOS weeds out Alt, Shift, and Ctrl scancodes, so an application never sees them. LHAPI looks for the "new" scancodes to generate the menu, and to recognize Shift+Arrow selection. See SYSDEFS.H for the scancode values generated for each shift key.

Debugging tip: breaking out of a System Manager application without calling m_fini or m_action(DO_FINI) will leave the keyboard hooked. Consequently, you'll have a really hard time typing anything with Shift not working right. During the debugging stage of an application, try to exit through a known point, or install a C exit handler that will clean up by calling m_fini.

* Syntax: void DISTANCE ResetAlt(void)
* Parameters: None
* Returns: None
* Related Calls: DoTopMenu(), MonitorAlt()

### ResetRepRule

This function resets the low-level graphics pixel replacement rule to the LHAPI-defined default.

* Syntax: void DISTANCE ResetRepRule(void)
* Parameters: None
* Returns: None

### ResetVideo

This function resets the internal LHAPI video state variables. This routine allows LHAPI to reset the display to the mode it wants it in and should be called by an application after it finishes directly calling any of the low-level graphics functions.

* Syntax: void DISTANCE ResetVideo(void)
* Parameters: None
* Returns: None

### SendAllMsg

This function sends the specified message to all windows in the active application.

* Syntax: void DISTANCE SendAllMsg(UINT Message, UINT Data, UINT Extra)
* Parameters: UINT Message Message to be sent.
* Returns: None

### SendFocusMsg

This function sends the specified message to the focus window.

* Syntax: int DISTANCE SendFocusMsg(UINT Message, UINT Data, UINT Extra)
* Parameters:

```
    UINT Message    Message to be sent.
    UINT Data       Optional component of message.
    UINT Extra      Optional component of message.
```

* Returns: 0 if successfully claimed.

Any other value indicates an error condition.

### SendMsg

This function sends the specified message to the specified window.

* Syntax: int DISTANCE SendMsg(PLHWINDOW Window, UINT Message, UINT Data, UINT Extra)
* Parameters:

```
    PLHWINDOW Window    Specific window to receive message.
    UINT Message        Message to be sent.
    UINT Data           Optional component of message.
    UINT Extra          Optional component of message.
```

* Returns: 0 - if successfully claimed.

Any other value indicates an error condition.

### SetCurrentFont

This function sets the system font to the given type. This service should only be used when an application directly calls the low-level graphics layer rather than using the DrawText() or DrawChar() services to output text to the display.

* Syntax: void DISTANCE SetCurrentFont(UINT font)
* Parameters: UINT font Font value to be used as current font. The possible font values are:
  * FONT_SMALL
  * FONT_NORMAL
  * FONT_LARGE
* Returns: None
* Related Calls: GetCurrentFont()

### SetDefaultFont

Sets the default font to use to the given type. This is the font that will be used if any windows structure contain FONT_DEFAULT in the Font field, or if FONT_DEFAULT is specified as an input parameter to any of the text drawing services.

* Syntax: void DISTANCE SetDefaultFont(UINT Font)
* Parameters: UINT Font Font value to be used as default. The possible font values are:
  * FONT_SMALL
  * FONT_NORMAL
  * FONT_LARGE
* Returns: None

### SetError

Saves the specified value in the ErrorNum field in the LHAPIBLOCK structure, if one is not already saved there.

Handler is an optional routine to be given control when an error is acknowledged.

* Syntax: int DISTANCE SetError(int ErrorNum)
* Parameters: int ErrorNum
* Returns: TRUE - if the specified error number was saved.

### SetErrorHandler

Sets Handler for Error. NULL means "use Standard Error Handler".

* Syntax: void DISTANCE SetErrorHandler(PLHFUNC Handler)
* Parameters: PLHFUNC Handler Specific handler to be used.
* Returns: None

### SetGlobalClipping

This function sets the master clipping against which all local clip regions are clipped. Calling this will also reset the local clipping region.

* Syntax: void DISTANCE SetGlobalClipping(int x1, int y1, int x2, int y2)
* Parameters:

```
    int x1    Horizontal location of the upper left corner of the global clipping region.
    int y1    Vertical location of the upper left corner of the global clipping region.
    int x2    Horizontal location of the lower right corner of the global clipping region.
    int y2    Vertical location of the lower right corner of the global clipping region.
```

* Returns: None

### SetHelpKey

This function sets the application-wide "Help" key. The help key is used internally by LHAPI. If an application does not explicitly set the help key, the default of \<F1\> is used. This service need only be called after InitializeLHAPI() is.

* Syntax: void DISTANCE SetHelpKey(UINT HelpKeyCode)
* Parameters: UINT HelpKeyCode Key value to be used as Help key.
* Returns: None

### SetLocalClipping

This function sets clipping region within a particular window.

* Syntax: void DISTANCE SetLocalClipping(int x1, int y1, int x2, int y2)
* Parameters:

```
    int x1   Horizontal location of the upper left corner of the local clipping region.
    int y1   Vertical location of the upper left corner of the local clipping region.
    int x2   Horizontal location of the lower right corner of the local clipping region.
    int y2   Vertical location of the lower right corner of the local clipping region.
```

* Returns: None
* Related Calls: GetLocalClipping, SetGlobalClipping

### SetMenuFont

sets the system font to be used for the menus.

* Syntax: void DISTANCE SetMenuFont(UINT Font)
* Parameters: UINT Font
* Returns: None

### SetRepRule

This function sets the low-level graphics pixel replacement rule. The valid replacement rules are

```
      REP_FORCE       0.
      REP_AND         1.
      REP_OR          2.
      REP_XOR         3.
      REP_NOTFORCE    4.
      REP_NOTAND      5.
      REP_NOTOR       6.
      REP_NOTXOR      7.
      REP_BITBLT      8.
```

* Syntax: void DISTANCE SetRepRule(UCHAR RepRule)
* Parameters: UCHAR RepRule Replacement rule value to be used.
* Returns: None

### ShadowBox

This function draws a Panel box with a shadow to the right and underneath. Note that the width and height include the shadowed area.

* Syntax: void DISTANCE ShadowBox(int x, int y, int w, int h)
* Parameters:

```
    int x      Horizontal location of upper left corner of rectangle.
    int y      Vertical location of upper left corner of rectangle.
    int w      Width of rectangle, including shadow.
    int h      Height of rectangle, including shadow.
```

* Returns: None

### ShowSymbol

This function displays a special symbol at the given location. Symbol IDs arelisted below:

```
    RADIO_OPEN      1.
    RADIO_FILLED    2.
    CHECK_OPEN      3.
    CHECK_FILLED    4.
    COMBO_ICON      5.
```

* Syntax: void DISTANCE ShowSymbol(int x, int y, UINT Symbol)
* Parameters:

```
    int x           Horizontal location to display symbol.
    int y           Vertical location to display symbol.
    UINT Symbol     Symbol value to be displayed.
```

* Returns: None

### SubclassMsg

This function sends the specified message to the specified window using a different class handler than the one specified in the LHWINDOW structure.

* Syntax: int DISTANCE SubclassMsg(PLHCLASS Class, PLHWINDOW Window, UINT Message, UINT Data, UINT Extra)
* Parameters:

```
    PLHCLASS Class      Specific class handler to be used.
    PLHWINDOW Window    Specific window to receive message.
    UINT Message        Message to be sent.
    UINT Data           Optional component of message.
    UINT Extra          Optional component of message.
```

* Returns: 0 - if successfully claimed

Any other value indicates an error condition.

### UninitializeLHAPI

The application tells LHAPI it is terminating.

**A note of practicality:** There is an unfortunate circumstance that appears again and again in system manager programming. An application recieves a E_TERM event either from the user closing the application through the low-memory closeout box, or by selecting the application for closing from the Application Manager. When an application recieves this E_TERM event, it is expected to close down gracefully. Part of a truely polite closedown would be calling "UninitializeLHAPI", but one of the side-effects of this is to send all windows a TERMINATE message. The catch is that your application hasn't gotten a E_ACTIV event, so you probably haven't reestablished the LHAPI block with ReactivateLHAPI. What happens in this case is that LHAPI thinks the LHAPI block is at the segment of your application but the offset of the last active application (whoops). Needless to say, good things don't come from this (most normally lock-ups, but sometimes funny-looking "Bullwinkle" screens). Calling ReactivateLHAPI, though will redisplay all windows and create a lot of screen flash--pretty unpleasant looking, since your app is supposed to be dying quietly.

There is a relatively simple solution to this: don't ever call UninitializeLHAPI. All it really does is send all open windows a TERMINATE message. None of the built-in LHAPI classes respond to this message. As far as future compatibility goes, none of the built-in applications call UninitializeLHAPI either! I personally guarantee that not calling UninitializeLHAPI will not have bad side-effects, now or for as long as I maintain the code :-)

* Syntax: void DISTANCE UninitializeLHAPI(void)
* Parameters: None
* Returns: None
