/* SCCS info - Module %M%  Version %I%  Date %G%  Time %U% */
/*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*/
/*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*/



/********************************************************************
 The Database Engine now comes in two flavors--a library that you
 can link in, or a System Manager version that you access just like
 all other System Manager calls through c_service.

 These macros are designed to make this interface transparent.  They
 are also designed to allow the database engine to intelligently make
 calls to itself.  The database engine is, however, partitioned into
 two System Manager overlays.  Calls within an overlay may be made
 directly, but calls between overlays must go through a System Manager
 equivalent of c_service.  This leaves four distinct possibilities for
 what a call to a DB routine translates to:

 DB_Example(Arg1) translates to the following when it is a ...

Call from inside or|  Call from outside  | Call from inside | Call from outside
outside DB when    |  DB when DB is in   | DB and in same   | DB and in other
DB is a .LIB       |  Sysmgr             | overlay          | overlay
-------------------+---------------------+------------------+-----------------
_DB_Example(Arg1);   c_service(SERVICE#,  _DB_Example(SMAPI  c_service(SERVICE#,
                             Arg1);        dbDummy, Arg1);               Arg1);

 Note that the actual function calls are prepended with an underscore--
 this namespace shadowing is used to keep the real function and the macro
 separate so this file can be included in the engine too.

 Although the c_service routines act differently inside and outside the
 SysMgr, they have the same name, so can be called the same.


 A macro DB_LIB if defined gives the direct library calls.  If it is not
 defined before DB.H is included, the calls are assumed to go through
 the SysMgr. For using this file within the database, there is an
 additional macro to specify which overlay the routine is in.  This
 macro is DB_OVL.  It should be #defined to 1 or 2 depending on the
 overlay being compiled.

 An additional macro, DB_INTERNAL is set if the calls produced require the
 additional parameter of calls inside the database engine.  For use of the
 database engine files only.

 Another point to note: the macro expansions rely on the compiler using
 some "intelligence" in compiling out dead code.  Since there is no way
 for a preprocessor macro to dynamically compile different code, these
 macros use the C tertiary operator and the current macro settings to
 generate one of two variants of code.  Since at compile time, the
 macros are constants, only one of the calls is generated by the compiler
 (even under "no" optimization, this checks out).


 MOVING FUNCTIONS FROM OVERLAY TO OVERLAY!!!
   Several spots must be modified to move a function from one overlay to
   another.
      1) The F_DB_* table below (make sure there are no duplicate function
         numbers).
      2) The file DSPTBLS.ASM that belongs to Lotus must be modified to
         reflect the changed function numbers.
      3) The pragma alloc_text() section at the bottom of DB.H.
      4) The #undef/#define DB_OVL ? before each group of functions in an
         overlay.
      5) The DB_DIRECT(ovl_num) macro in each function expansion.

 ADDING ADDITIONAL FUNCTIONS!!!
    If the function is globally visible (DB_*) ...
      1) You will need to add a dispatch number (F_DB_*) in one of the two
         overlay banks below.  If the routine calls other DB functions, try
         to put that function in the same overlay as the majority of the
         calls.
      2) The file DSPTBLS.ASM that belongs to Lotus must be modified to
         include the new function number.
      3) Add a macro expansion for the function in db.h.  Follow the model
         of the existing functions.  Make sure DB_DIRECT() matches the
         overlay you've selected!
    For any additional functions...
      4) Before the function, place a #undef/#define DB_OVL x pair,
         corresponding to the overlay you've selected.
      5) IMPORTANT.  This step is easy to forget--if the function is in
         the 2nd overlay only, YOU MUST add the function to the
         #pragma alloc_text at the bottom of DB.H.  THIS APPLIES TO ALL
         FUNCTIONS (EVEN INTERNAL ONES).  Additionally, you will need to
         add the prototype of the function in DB_PVT.H, so the pragma
         won't choke.

****************************************************************************/

#ifndef CLASS_BASE
#error You must #include interfac.h before you #include db.h
#endif



/* We cannot have DB_LIB defined if we are inside either of the overlays */

#ifdef DB_LIB
#ifdef DB_OVL
#error Cannot use DB_OVL and DB_LIB at the same time!
#endif
#endif



/* DB_DIRECT is set to 1 if the calls go directly to the library */
/* This either happens if the user is linking DB.LIB, or if we are */
/* within the DB engine trying to call somthing in the same overlay */

#ifdef DB_LIB
#define  DB_DIRECT(ovl_num) (1)
#else
#define  DB_DIRECT(ovl_num) (DB_OVL==(0*ovl_num))
#endif


/* If DB_OVL is not defined, set it to 100 so that the macros expand properly */
/* We want to make sure that it won't equal any of the possible values for */
/* DB_DIRECT (0,1,2) */
#ifndef DB_OVL
#define DB_OVL 100
#endif


/* From outside the engine, the call is "normal"; from inside the engine, */
/* the dummy SMAPI parameter must be passed to line up the stack.  The two */
/* versions are for calls with 0 and for 1 or more parameters.  SMPREFIX is */
/* used in the prototype, and SMCALL is used in the function call.  Note that */
/* if the DB_LIB option is defined, no dummy param is used--only if it is */
/* compiled for a system manager overlay. */

#if defined(DB_LIB) || (!defined(DB_INTERNAL))
#define DBSMPREFIX0
#define DBSMPREFIX1
#define DBSMCALL0
#define DBSMCALL1
#else
#define DBSMPREFIX0 SMAPI dbDummyParm
#define DBSMPREFIX1 SMAPI dbDummyParm,
#define DBSMCALL0   dbDummy
#define DBSMCALL1   dbDummy,
#endif






/* The following sets up the call tables for the SysMgr--two classes (ovls) */

#define SC_DB1     ((CLASS_BASE + 27)*256 + FNCT_BASE)
#define SC_DB2     ((CLASS_BASE + 28)*256 + FNCT_BASE)


#define F_DB_CREATE                (SC_DB1 +  0)
#define F_DB_OPEN                  (SC_DB1 +  1)
#define F_DB_FLUSHFILE             (SC_DB1 +  2)
#define F_DB_CLOSE                 (SC_DB1 +  3)
#define F_DB_SHUTDOWN              (SC_DB1 +  4)
#define F_DB_READRECORD            (SC_DB1 +  5)
#define F_DB_RECORDSIZE            (SC_DB1 +  6)
#define F_DB_NEXTRECORD            (SC_DB1 +  7)
#define F_DB_WRITERECORD           (SC_DB1 +  8)
#define F_DB_DELETERECORD          (SC_DB1 +  9)
#define F_DB_LOADFIELDDEFS         (SC_DB1 + 10)
#define F_DB_GETFIELD              (SC_DB1 + 11)
#define F_DB_GETFIELDSTRINGS       (SC_DB1 + 12)
#define F_DB_DEFAULTCALLBACK       (SC_DB1 + 13)
#define F_DB_GETFIELDNAME          (SC_DB1 + 14)
#define F_DB_GETFIELDINDEX         (SC_DB1 + 15)
#define F_DB_CREATELOOKUPTABLE     (SC_DB1 + 16)
#define F_DB_ORDER                 (SC_DB1 + 17)
#define F_DB_CREATEVIEWPTTABLE     (SC_DB1 + 18)
#define F_DB_MODIFYVIEWPT          (SC_DB1 + 19)
#define F_DB_SETCURRENTVIEWPT      (SC_DB1 + 20)
#define F_DB_STOREVIEWPT           (SC_DB1 + 21)
#define F_DB_INVIEWPT              (SC_DB1 + 22)
#define F_DB_FINDRECORD            (SC_DB1 + 23)
#define F_DB_FINDMEMORYRECORD      (SC_DB1 + 24)
#define F_DB_FINDDATARECORD        (SC_DB1 + 25)
#define F_DB_GETTIMESTAMP          (SC_DB1 + 26)
#define F_DB_GETDATE               (SC_DB1 + 27)
#define F_DB_GETTIME               (SC_DB1 + 28)
#define F_DB_TIMETOSTRING          (SC_DB1 + 29)
#define F_DB_DATETOSTRING          (SC_DB1 + 30)
#define F_DB_STRINGTODATE          (SC_DB1 + 31)
#define F_DB_STRINGTOTIME          (SC_DB1 + 32)
#define F_ENCODE                   (SC_DB1 + 33)
#define F_AVAILLOOKUPENTRY         (SC_DB1 + 34)
#define F_DB_WINTRANSLATE          (SC_DB1 + 35)


#define F_DB_INIT                  (SC_DB2 +  0)
#define F_DB_RESET                 (SC_DB2 +  1)
#define F_DB_DEACTIVATE            (SC_DB2 +  2)
#define F_DB_REACTIVATE            (SC_DB2 +  3)
#define F_DB_ISSELECTED            (SC_DB2 +  4)
#define F_DB_SELECT                (SC_DB2 +  5)
#define F_DB_COLLECTGARBAGE        (SC_DB2 +  6)
#define F_DB_UNDO                  (SC_DB2 +  7)
#define F_DB_SETUNDOPOINT_         (SC_DB2 +  8)
#define F_DB_PARSEFISL             (SC_DB2 +  9)
#define F_DB_CHANGEPASSWORD        (SC_DB2 + 10)
#define F_DB_VERIFYPASSWORD        (SC_DB2 + 11)
#define F_DB_AUTOGOTO              (SC_DB2 + 12)
#define F_DB_CARDTOFISL            (SC_DB2 + 13)
#define F_DB_FISLTOCARD            (SC_DB2 + 14)
#define F_DB_COMPRESSDELETE        (SC_DB2 + 15)
#define F_DB_WRITEINPLACE          (SC_DB2 + 16)
#define F_DB_NEXTNEXTRECORD        (SC_DB2 + 17)
#define F_DB_COPYRECORD            (SC_DB2 + 18)
#define F_DB_CHECKCATEGORY         (SC_DB2 + 19)
#define F_DB_FIELDINFISL           (SC_DB2 + 20)
#define F_DB_FISLFIELDTRANSLATE    (SC_DB2 + 21)
#define F_DB_UNPARSEFISL           (SC_DB2 + 22)
#define F_DB_CREATEVIEWPTINMEMORY  (SC_DB2 + 23)
#define F_DB_CARDCHANGED           (SC_DB2 + 24)
#define F_DB_WINSTRTO850           (SC_DB2 + 25)
#define F_DB_WINGLEDTO850          (SC_DB2 + 26)
#define F_DB_ADVANCEFISL           (SC_DB2 + 27)


/* This nonsense is what is pushed on the stack internally by the SysMgr */
/* when it calls a function.  It must passed by value as the first param */
/* so that it lines up with that the stack already looks like.  NOTE: This */
/* "lines up" with the appropriate fields ONLY when the DB function has */
/* been called from outside.  That is, if a DB function is called from an */
/* app, SMAPI.AppDS (for example) will be equal to the app's DS when */
/* inside the function.  THIS IS NOT TRUE for any internal calls, because */
/* these calls are made directly, and junk is copied onto the stack to */
/* satisfy the stack positioning.  The effect of this is that NONE OF THESE */
/* VALUES CAN BE RELIABLY CHECKED/MODIFIED. */

typedef struct {
  long BankSwitchInfo;
  _segment AppDS;
  long LHSTUBReturnAddr;
  int CPUFlags;
  long AppReturnAddr;
  int ClassFnNumber;
} SMAPI;


extern SMAPI dbDummy;




/* APP_NEAR
   This define allows the application variables (both local AND global) to
   be accessed through the stack segment (which will be preserved), and to
   allow the DB engine variables to reside in the App Mgr's Data Segment.
   This REQUIRES the application's calling model to have DS==SS, AND that
   the DB engine be compiled with the /Aw switch (DS!=SS).

   All "near" variables passed in from the application are declared of this
   type so the DB engine can access them with a SS: override, and access
   its own global variables with a "DS: override".
*/

#ifdef DB_INTERNAL
#define APP_NEAR _based(_segname("_STACK"))
#else
#define APP_NEAR _near
#endif


/* USE_APP_DS/RESTORE_SM_DS
 *
 * These macros must bracket any call to a System Manager Memory function.
 * The reason for this is that these functions assume DS is pointing to
 * the applications data seg (which isn't the case), so we need to temporarily
 * switch to app's DS and back to SM DS.
 *
 * Needless to say, bracketing these functions must be done very
 * carefully as they leave args on the stack.  Try to bracket the
 * m_memory call only; for anything else, it is wise to examine
 * the resulting assembly code (COPTS=/Fc).  ALSO: An optimization that
 * the compiler generates will kill the stack if the procedure using
 * these macros DOES NOT HAVE ANY LOCAL VARIABLES DECLARED.  Be forewarned.
 */


#define USE_APP_DS _asm push ds \
                   _asm push ss \
                   _asm pop ds

#define RESTORE_SM_DS _asm pop ds
